const definitions = require("../src/definitions");
const flatMap = require("array.prototype.flatmap");
const {
  typeSignature,
  iterateProps,
  mapProps,
  filterProps,
  unique,
} = require("./util");

const stdout = process.stdout;

const jsTypes = ["string", "number", "boolean"];

const quote = (value) => `"${value}"`;

function params(fields) {
  const optionalDefault = (field) =>
    field.default ? ` = ${field.default}` : "";
  return mapProps(fields)
    .map((field) => `${typeSignature(field)}${optionalDefault(field)}`)
    .join(",");
}

function assertParamType({ assertNodeType, array, name, type }) {
  if (array) {
    // TODO - assert contents of array?
    return `assert(typeof ${name} === "object" && typeof ${name}.length !== "undefined")\n`;
  } else {
    if (jsTypes.includes(type)) {
      return `assert(
          typeof ${name} === "${type}",
          "Argument ${name} must be of type ${type}, given: " + typeof ${name}
      )`;
    }

    if (assertNodeType === true) {
      return `assert(
        ${name}.type === "${type}",
        "Argument ${name} must be of type ${type}, given: " + ${name}.type
      )`;
    }

    return "";
  }
}

function assertParam(meta) {
  const paramAssertion = assertParamType(meta);

  if (paramAssertion === "") {
    return "";
  }

  if (meta.maybe || meta.optional) {
    return `
      if (${meta.name} !== null && ${meta.name} !== undefined) {
        ${paramAssertion};
      }
    `;
  } else {
    return paramAssertion;
  }
}

function assertParams(fields) {
  return mapProps(fields).map(assertParam).join("\n");
}

function buildObject